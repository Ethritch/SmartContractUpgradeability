# SmartContractUpgradeability
The Transfer Contracts are an example implementation of the EIP 1822 and the EternalStorage is an example of Eternal Storage pattern

These contracts are not complete and could have a lot more functionality and security added. Their purpose is to exemplify the proxy patterns of the EIP 1822 and Eternal Storage.

To test the Transfer contracts, depoly the contracts using Remix IDE. Deploy the MyFinalContract.sol first. To deploy the proxy you need the method signature of the function constructor1(). To aquire this signature type the command: web3.utils.sha3('constructor1()').substring(0, 10). This will return a the first 10 characters of byte code that is your method signature for the function. Enter those characters into the bytes field and then copy the address that MyFinalContract is running on and put that in the address field and then click transact to deploy the proxy. Lastly re-deploy the MyFinalContract and deploy it using the atAddress button and give it the proxy address so Remix knows you are running it using the proxy. To upgrade the contract deploy the upgrade contract and enter the address it is deployed at into the function updatecode(). This will update the address for the proxy and it will update to the new contract.


To test the Eternal Storage example, deploy the EternalStorage contract first. Then deploy the Reservations contract by entering the address that the EternalStorage contract is running at into the address field. This will link the contracts together. If you want to update the contract, deploy the upgrade to the address where the EternalStorage is running and kill the previous contract. Again note that These contracts in the EternalStorage.sol file have limited fuctionality and limited security. They are limited and advised to be implemented at the doers risk. For example the array function of the upgradedreservations contract will only transfer the storage of 10 items for checking against future reservations. 
